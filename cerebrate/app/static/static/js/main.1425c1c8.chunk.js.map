{"version":3,"sources":["SelectTagsInput.js","ReplaySelector.js","SubmitReplayForm.js","Guy.js","App.js","serviceWorker.js","index.js"],"names":["SelectTagsInput","props","tagPrefix","tag","indexOf","this","slice","length","tagIntent","tags","selectedTags","setSelectedTags","createNewItemRenderer","query","active","handleClick","onClick","text","itemRenderer","item","modifiers","matchesPredicate","removePrefix","itemPredicate","index","exactMatch","includes","toLocaleLowerCase","initialContent","items","selectedItems","filter","createNewItemFromQuery","onItemSelect","push","resetOnSelect","tagRenderer","tagInputProps","onRemove","valueAsString","value","splice","tagProps","intent","openOnKeyDown","fill","placeholder","React","Component","getFilename","path","split","pop","ReplaySelector","state","valid","setReplayId","setReplayData","onInputChange","event","target","file","files","setState","hashReader","FileReader","addEventListener","data","result","hash","CryptoJS","SHA256","lib","WordArray","create","toString","readAsArrayBuffer","dataReader","readAsDataURL","inputProps","accept","SubmitReplayForm","replayId","setNotes","submitTaggedReplay","other","interactive","elevation","Elevation","TWO","className","label","disabled","Intent","SUCCESS","DANGER","PRIMARY","onChange","debugFunc","args","console","log","Guy","self","EXAMPLE_TAGS","App","replayData","notes","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.1425c1c8.chunk.js","sourcesContent":["import React from \"react\";\nimport { MenuItem } from \"@blueprintjs/core\";\nimport { MultiSelect } from \"@blueprintjs/select\";\n\nclass SelectTagsInput extends React.Component {\n  constructor(props) {\n    super(props);\n    const { tagPrefix } = props;\n    this.tagPrefix = tagPrefix;\n  }\n\n  removePrefix(tag) {\n    if (tag.indexOf(this.tagPrefix) !== 0) {\n      return tag;\n    }\n\n    return tag.slice(this.tagPrefix.length);\n  }\n\n  render() {\n    const { tagIntent, tags, selectedTags, setSelectedTags } = this.props;\n\n    return (\n      <MultiSelect\n        createNewItemRenderer={(query, active, handleClick) => {\n          return (\n            <MenuItem active={active} onClick={handleClick} text={query} />\n          );\n        }}\n        itemRenderer={(item, { modifiers, handleClick }) => {\n          if (!modifiers.matchesPredicate) {\n            return null;\n          }\n\n          return (\n            <MenuItem\n              active={modifiers.active}\n              onClick={handleClick}\n              text={this.removePrefix(item)}\n            />\n          );\n        }}\n        itemPredicate={(query, item, index, exactMatch) =>\n          item.indexOf(this.tagPrefix) === 0 &&\n          !selectedTags.includes(item) &&\n          item.includes(query.toLocaleLowerCase(\"en-GB\"))\n        }\n        initialContent={null}\n        items={tags}\n        selectedItems={selectedTags.filter(\n          (tag) => tag.indexOf(this.tagPrefix) === 0\n        )}\n        createNewItemFromQuery={(query) => this.tagPrefix + query}\n        onItemSelect={(item) => {\n          if (!selectedTags.includes(item)) {\n            selectedTags.push(item);\n            setSelectedTags(selectedTags);\n          }\n        }}\n        resetOnSelect={true}\n        tagRenderer={(item) => this.removePrefix(item)}\n        tagInputProps={{\n          onRemove: (valueAsString, index, value) => {\n            selectedTags.splice(\n              selectedTags.indexOf(this.tagPrefix + valueAsString),\n              1\n            );\n            setSelectedTags(selectedTags);\n          },\n          tagProps: { intent: tagIntent },\n        }}\n        openOnKeyDown={true}\n        fill={true}\n        placeholder={\"Tags...\"}\n      />\n    );\n  }\n}\n\nexport default SelectTagsInput;\n","import React from \"react\";\nimport { FileInput } from \"@blueprintjs/core\";\nimport CryptoJS from \"crypto-js/crypto-js\";\nimport \"crypto-js/lib-typedarrays\";\n\nconst getFilename = (path) => path.split(\"\\\\\").pop().split(\"/\").pop();\n\nclass ReplaySelector extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      valid: true,\n      text: \"Choose replay file...\",\n    };\n  }\n\n  render() {\n    const { setReplayId, setReplayData } = this.props;\n\n    return (\n      <FileInput\n        text={this.state.text}\n        onInputChange={(event) => {\n          const path = event.target.value;\n          const file = event.target.files[0];\n\n          this.setState({ text: getFilename(path) });\n\n          const hashReader = new FileReader();\n          hashReader.addEventListener(\"load\", (event) => {\n            const data = event.target.result;\n            const hash = CryptoJS.SHA256(\n              CryptoJS.lib.WordArray.create(data)\n            ).toString();\n            setReplayId(hash);\n          });\n          hashReader.readAsArrayBuffer(file);\n\n          const dataReader = new FileReader();\n          dataReader.addEventListener(\"load\", (event) => {\n            const data = event.target.result;\n            setReplayData(data);\n          });\n          dataReader.readAsDataURL(file);\n        }}\n        inputProps={{ accept: \".sc2replay\" }}\n      />\n    );\n  }\n}\n\nexport default ReplaySelector;\n","import React from \"react\";\n\nimport {\n  Button,\n  Card,\n  Elevation,\n  FormGroup,\n  H2,\n  InputGroup,\n  Intent,\n  TextArea,\n} from \"@blueprintjs/core\";\n\nimport \"./SubmitReplayForm.css\";\nimport SelectTagsInput from \"./SelectTagsInput\";\nimport ReplaySelector from \"./ReplaySelector\";\n\nfunction SubmitReplayForm({ replayId, setNotes, submitTaggedReplay, ...other }) {\n  return (\n    <Card\n      interactive={true}\n      elevation={Elevation.TWO}\n      className={\"SubmitReplayForm-card\"}\n    >\n      <H2>Save replay tags</H2>\n      <br />\n      <FormGroup label=\"Replay ID\">\n        <InputGroup disabled={true} fill={true} value={replayId} />\n      </FormGroup>\n      <FormGroup label=\"Replay path\">\n        <ReplaySelector {...other} />\n      </FormGroup>\n      <FormGroup label=\"Player tags\">\n        <SelectTagsInput\n          {...other}\n          tagPrefix={\"player:\"}\n          tagIntent={Intent.SUCCESS}\n        />\n      </FormGroup>\n      <FormGroup label=\"Opponent tags\">\n        <SelectTagsInput\n          {...other}\n          tagPrefix={\"opponent:\"}\n          tagIntent={Intent.DANGER}\n        />\n      </FormGroup>\n      <FormGroup label=\"Game tags\">\n        <SelectTagsInput\n          {...other}\n          tagPrefix={\"game:\"}\n          tagIntent={Intent.PRIMARY}\n        />\n      </FormGroup>\n      <FormGroup label=\"Notes\">\n        <TextArea\n          fill={true}\n          onChange={(event) => setNotes(event.target.value)}\n        />\n      </FormGroup>\n      <Button fill={true} intent={Intent.SUCCESS} onClick={submitTaggedReplay}>\n        Save tags\n      </Button>\n    </Card>\n  );\n}\n\nexport default SubmitReplayForm;\n","const debugFunc = (...args) => console.log(args);\n\nconst Guy = {\n  // eslint-disable-next-line no-restricted-globals\n  submitTaggedReplay: (...args) => ((self && self.submitTaggedReplay) || debugFunc)(...args),\n};\n\nexport default Guy;\n","import React from \"react\";\nimport \"./App.scss\";\nimport SubmitReplayForm from \"./SubmitReplayForm\";\nimport Guy from \"./Guy\";\n\nconst EXAMPLE_TAGS = [\n  \"player:terran\",\n  \"player:protoss\",\n  \"player:zerg\",\n  \"player:macro\",\n  \"player:all_in\",\n  \"player:2_base_all_in\",\n  \"player:mech\",\n  \"player:bio\",\n  \"player:stargate\",\n  \"player:twilight\",\n  \"player:dt\",\n  \"player:mass_pheonix\",\n  \"player:mass_void_ray\",\n  \"player:air_toss\",\n  \"player:cannon_rush\",\n  \"player:proxy_barracks\",\n  \"player:proxy_hatch\",\n  \"player:winner\",\n  \"player:loser\",\n\n  \"opponent:terran\",\n  \"opponent:protoss\",\n  \"opponent:zerg\",\n  \"opponent:macro\",\n  \"opponent:all_in\",\n  \"opponent:2_base_all_in\",\n  \"opponent:mech\",\n  \"opponent:bio\",\n  \"opponent:stargate\",\n  \"opponent:twilight\",\n  \"opponent:dt\",\n  \"opponent:mass_pheonix\",\n  \"opponent:mass_void_ray\",\n  \"opponent:air_toss\",\n  \"opponent:cannon_rush\",\n  \"opponent:proxy_barracks\",\n  \"opponent:proxy_hatch\",\n  \"opponent:winner\",\n  \"opponent:loser\",\n\n  \"game:zvp\",\n  \"game:zvt\",\n  \"game:zvz\",\n  \"game:tvz\",\n  \"game:tvp\",\n  \"game:tvt\",\n  \"game:pvt\",\n  \"game:pvz\",\n  \"game:pvp\",\n  \"game:short\",\n  \"game:long\",\n  \"game:basetrade\",\n];\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      replayId: \"\",\n      replayData: \"\",\n      selectedTags: [],\n      notes: \"\",\n\n      setReplayId: (replayId) => this.setState({ replayId: replayId }),\n\n      setReplayData: (replayData) => this.setState({ replayData: replayData }),\n\n      setSelectedTags: (selectedTags) =>\n        this.setState({ selectedTags: selectedTags }),\n\n      setNotes: (notes) => this.setState({ notes: notes }),\n\n      submitTaggedReplay: () =>\n        Guy.submitTaggedReplay({\n          replayId: this.state.replayId,\n          replayData: this.state.replayData,\n          selectedTags: this.state.selectedTags,\n          notes: this.state.notes,\n        }),\n    };\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <SubmitReplayForm tags={EXAMPLE_TAGS} {...this.state} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}